# LangChain Runnable 학습 순서 (교육용 로드맵)

## 1) 준비운동: 프롬프트·LLM·파서 기초
**목표**: 최소 체인 흐름 이해(프롬프트 → LLM → 문자열 파싱)  
**API**: `ChatPromptTemplate`, `PromptTemplate`, `ChatOpenAI`, `StrOutputParser`  
**미션**: 한 문장을 요약하는 단일 체인 만들기  
**체크**: 프롬프트 변수 누락/이스케이프 오류 없이 단일 `.invoke()` 성공

---

## 2) 파이프 개념: Runnable 파이프라인의 `|` 합성
**목표**: 파이프 연산자(`|`)로 단계 연결  
**API**: 체인 합성, `invoke()`/`ainvoke()`  
**미션**: “입력→요약→한국어번역” 2단계 체인  
**체크**: 체인의 입력/출력 스키마가 자연스럽게 이어짐

---

## 3) 후처리·데이터 가공: `RunnableLambda`
**목표**: LLM 출력 후 가벼운 가공/스키마 변환  
**API**: `RunnableLambda`  
**미션**: 요약 결과에 메타데이터(길이, 토큰 수 추정 등) 붙이기  
**체크**: Lambda 내부 예외 처리 및 dict 스키마 일관성

---

## 4) 상태 보존·필드 추가: `RunnablePassthrough.assign`
**목표**: **기존 입력을 유지**하면서 중간 산출물 누적  
**API**: `RunnablePassthrough.assign()`  
**미션**: 제품명 → 회사명 생성 → 캐치프레이즈 생성(회사명/제품 둘 다 결과에 남기기)  
**체크**: assign 단계마다 키 충돌/누락 없이 결과 dict 누적

---

## 5) 입력 스키마 매핑: `RunnableMap`
**목표**: 외부 스키마를 내부 체인 스키마에 맞게 매핑  
**API**: `RunnableMap`  
**미션**: `{"question": "..."} → {"input": "..."} → 체인 재사용`  
**체크**: 키 누락 시 기본값 처리(`.get`)로 안전성 확보

---

## 6) 출력 형식 강제: 구조화 파서
**목표**: LLM 출력을 신뢰 가능한 구조로 수집  
**API**: `CommaSeparatedListOutputParser`, `JsonOutputParser`  
**미션**: 후보 N개를 CSV/JSON으로 받아 리스트/객체로 파싱  
**체크**: 프롬프트에 `get_format_instructions()` 삽입, JSON 중괄호 이스케이프

---

## 7) 동시성: 병렬/배치 실행
**목표**: 처리량·속도 향상 패턴 익히기  
**API**: `RunnableParallel`, `.batch()`, `config={"max_concurrency": K}`  
**미션**: 동일 문장을 3개 언어로 **순차 vs 병렬** 실행 → 시간 비교  
**체크**: 결과 스키마(각 체인 다름) 정리, 타이머로 속도 차 가시화

---

## 8) 예외 대응: 폴백·재시도·타임아웃
**목표**: 프로덕션 안정성 위한 방어선  
**API**: `with_fallbacks()`, `config={"timeout": ...}`, (재시도는 외부 데코레이터/재시도 유틸로)  
**미션**: 번역 실패 시 기본 메시지 반환, 특정 케이스 타임아웃 테스트  
**체크**: **폴백 출력 스키마 동일성** 유지

---

## 9) 분기·라우팅: 조건부 실행
**목표**: 입력에 따라 다른 체인 경로 선택  
**API**: (버전에 따라) `RunnableBranch` 또는 수동 라우팅(`RunnableLambda`로 분기)  
**미션**: 언어 감지 후 한국어면 요약→영어면 번역 경로로 분기  
**체크**: 분기 후 결과 스키마를 최종 단계에서 통일

---

## 10) 설정·관측: 구성/태깅/로깅/캐싱
**목표**: 운영 관점 품질 관리  
**API**: `RunnableConfig`(또는 `config` dict), tags/metadata, (옵션) cache 설정  
**미션**: 체인에 태그 부여, 요청별 타임아웃/동시성 조절, 간단 로깅  
**체크**: 동일 체인 다양한 실행 설정으로 재사용

---

## 11) 미니 프로젝트: RAG 없이 “문서기반 Q&A lite”
**목표**: 지금까지 배운 Runnable 조립 전부 활용  
**구성**:
- PDF 텍스트 추출 → 청크 분할(슬라이딩 윈도우) → 관련 청크 선택(간단 키워드/TF-IDF)  
- 선택 청크만 LLM에 전달 → 구조화 파서로 답 변환  
- 실패 시 폴백 텍스트, 병렬로 상위 K청크 질의, 최종 투표/랭킹  
**체크**: 슬라이딩 윈도우, 병렬 K개, 폴백, 파서, 로그/타임아웃 모두 반영

---

## 12) 확장 과제(선택)
- **스코어링 파이프라인**: 후보 다발 → JSON 점수화 → 상위 N → 후보별 슬로건 병렬 생성  
- **툴/함수 호출 연동**: 체인 중간에 외부 함수(검색/DB) 바인딩  
- **스트리밍**: 토큰 스트리밍으로 사용자 경험 개선

---

## 권장 학습 순서 요약
1. 프롬프트/LLM/파서  
2. 파이프 합성  
3. `RunnableLambda`  
4. `RunnablePassthrough.assign`  
5. `RunnableMap`  
6. 구조화 파서(포맷 지시)  
7. 병렬/배치 + 타이머 비교  
8. 폴백/타임아웃  
9. 분기/라우팅  
10. 설정/관측  
11. 미니 프로젝트(Runnable 종합)  
12. 확장 과제
