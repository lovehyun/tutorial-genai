<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple LLM Demo</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .section {
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 15px;
            border-left: 5px solid #667eea;
        }
        
        .section h2 {
            color: #2c3e50;
            margin-bottom: 15px;
        }
        
        .input-group {
            margin: 15px 0;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #34495e;
        }
        
        textarea, input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
            box-sizing: border-box;
        }
        
        textarea:focus, input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
            transition: transform 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .output {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
            margin: 10px 0;
        }
        
        .vector-viz {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(40px, 1fr));
            gap: 5px;
            margin: 10px 0;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .vector-cell {
            background: #3498db;
            color: white;
            padding: 5px;
            text-align: center;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #ecf0f1;
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            transition: width 0.3s;
            border-radius: 10px;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .metric-card {
            background: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }
        
        .attention-viz {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            margin: 10px 0;
        }
        
        .attention-cell {
            aspect-ratio: 1;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¤– Simple LLM Implementation</h1>
        
        <div class="section">
            <h2>ğŸ“š 1. í›ˆë ¨ ë°ì´í„° ì…ë ¥</h2>
            <div class="input-group">
                <label>í›ˆë ¨í•  í…ìŠ¤íŠ¸ ë°ì´í„°:</label>
                <textarea id="trainingData" rows="6" placeholder="í›ˆë ¨í•  í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”. ì˜ˆ: ì•ˆë…•í•˜ì„¸ìš”. ì €ëŠ” AIì…ë‹ˆë‹¤. AIëŠ” ì¸ê³µì§€ëŠ¥ì„ ì˜ë¯¸í•©ë‹ˆë‹¤...">ì•ˆë…•í•˜ì„¸ìš”. ì €ëŠ” AIì…ë‹ˆë‹¤. AIëŠ” ì¸ê³µì§€ëŠ¥ì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ì¸ê³µì§€ëŠ¥ì€ ì»´í“¨í„°ê°€ ì‚¬ëŒì²˜ëŸ¼ ìƒê°í•˜ê³  í•™ìŠµí•˜ëŠ” ê¸°ìˆ ì…ë‹ˆë‹¤. ê¸°ìˆ ì€ ìš°ë¦¬ ì‚¶ì„ í¸ë¦¬í•˜ê²Œ ë§Œë“­ë‹ˆë‹¤. ì‚¶ì€ ì†Œì¤‘í•©ë‹ˆë‹¤. ì†Œì¤‘í•œ ê²ƒë“¤ì„ ì§€ì¼œì•¼ í•©ë‹ˆë‹¤.</textarea>
            </div>
            <button onclick="preprocessData()">ë°ì´í„° ì „ì²˜ë¦¬ ì‹œì‘</button>
        </div>
        
        <div class="section">
            <h2>ğŸ”¤ 2. í† í¬ë‚˜ì´ì œì´ì…˜ & ì–´íœ˜ì§‘ êµ¬ì¶•</h2>
            <div class="output" id="tokenizationOutput">ë°ì´í„°ë¥¼ ì „ì²˜ë¦¬í•˜ë©´ í† í°í™” ê²°ê³¼ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</div>
            <div class="metrics">
                <div class="metric-card">
                    <div class="metric-value" id="vocabSize">0</div>
                    <div>ì–´íœ˜ì§‘ í¬ê¸°</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="sequenceLength">0</div>
                    <div>ì‹œí€€ìŠ¤ ê¸¸ì´</div>
                </div>
            </div>
        </div>
        
        <div class="section">
            <h2>ğŸ§  3. ëª¨ë¸ ì•„í‚¤í…ì²˜ ì´ˆê¸°í™”</h2>
            <div class="input-group">
                <label>ì„ë² ë”© ì°¨ì›:</label>
                <input type="number" id="embeddingDim" value="32" min="16" max="128">
            </div>
            <div class="input-group">
                <label>ì–´í…ì…˜ í—¤ë“œ ìˆ˜:</label>
                <input type="number" id="numHeads" value="4" min="1" max="8">
            </div>
            <button onclick="initializeModel()">ëª¨ë¸ ì´ˆê¸°í™”</button>
            <div class="output" id="modelOutput">ëª¨ë¸ì„ ì´ˆê¸°í™”í•˜ë©´ ì•„í‚¤í…ì²˜ ì •ë³´ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</div>
        </div>
        
        <div class="section">
            <h2>ğŸ“Š 4. ë²¡í„° ê³µê°„ ì‹œê°í™”</h2>
            <div id="embeddingViz">
                <p>ëª¨ë¸ì„ ì´ˆê¸°í™”í•˜ë©´ ì„ë² ë”© ë²¡í„°ë“¤ì´ ì—¬ê¸°ì— ì‹œê°í™”ë©ë‹ˆë‹¤.</p>
            </div>
        </div>
        
        <div class="section">
            <h2>ğŸƒâ€â™‚ï¸ 5. ëª¨ë¸ í›ˆë ¨</h2>
            <div class="input-group">
                <label>ì—í¬í¬ ìˆ˜:</label>
                <input type="number" id="epochs" value="50" min="10" max="200">
            </div>
            <div class="input-group">
                <label>í•™ìŠµë¥ :</label>
                <input type="number" id="learningRate" value="0.01" step="0.001" min="0.001" max="0.1">
            </div>
            <button onclick="trainModel()">í›ˆë ¨ ì‹œì‘</button>
            <div class="progress-bar">
                <div class="progress-fill" id="trainingProgress" style="width: 0%"></div>
            </div>
            <div class="output" id="trainingOutput">í›ˆë ¨ì„ ì‹œì‘í•˜ë©´ ì†ì‹¤ê°’ê³¼ ì§„í–‰ìƒí™©ì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</div>
        </div>
        
        <div class="section">
            <h2>ğŸ” 6. ì–´í…ì…˜ ì‹œê°í™”</h2>
            <div id="attentionViz">
                <p>í›ˆë ¨ í›„ ì–´í…ì…˜ íŒ¨í„´ì´ ì—¬ê¸°ì— ì‹œê°í™”ë©ë‹ˆë‹¤.</p>
            </div>
        </div>
        
        <div class="section">
            <h2>ğŸ’­ 7. ì¶”ë¡  í…ŒìŠ¤íŠ¸</h2>
            <div class="input-group">
                <label>ì‹œì‘ í…ìŠ¤íŠ¸:</label>
                <input type="text" id="seedText" placeholder="ì˜ˆ: ì•ˆë…•" value="ì•ˆë…•">
            </div>
            <div class="input-group">
                <label>ìƒì„±í•  í† í° ìˆ˜:</label>
                <input type="number" id="generateLength" value="10" min="1" max="50">
            </div>
            <button onclick="generateText()">í…ìŠ¤íŠ¸ ìƒì„±</button>
            <div class="output" id="generationOutput">ìƒì„±ëœ í…ìŠ¤íŠ¸ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</div>
        </div>
    </div>

    <script>
        // ì „ì—­ ë³€ìˆ˜ë“¤
        let vocabulary = new Map();
        let reverseVocab = new Map();
        let tokenizedData = [];
        let model = null;
        let trainingData = [];
        
        // ê°„ë‹¨í•œ Matrix í´ë˜ìŠ¤
        class Matrix {
            constructor(rows, cols, values = null) {
                this.rows = rows;
                this.cols = cols;
                this.data = values || Array(rows).fill().map(() => 
                    Array(cols).fill().map(() => (Math.random() - 0.5) * 0.1)
                );
            }
            
            multiply(other) {
                if (this.cols !== other.rows) {
                    throw new Error("Matrix dimensions don't match");
                }
                const result = new Matrix(this.rows, other.cols);
                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < other.cols; j++) {
                        result.data[i][j] = 0;
                        for (let k = 0; k < this.cols; k++) {
                            result.data[i][j] += this.data[i][k] * other.data[k][j];
                        }
                    }
                }
                return result;
            }
            
            add(other) {
                const result = new Matrix(this.rows, this.cols);
                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        result.data[i][j] = this.data[i][j] + other.data[i][j];
                    }
                }
                return result;
            }
            
            transpose() {
                const result = new Matrix(this.cols, this.rows);
                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        result.data[j][i] = this.data[i][j];
                    }
                }
                return result;
            }
            
            softmax() {
                const result = new Matrix(this.rows, this.cols);
                for (let i = 0; i < this.rows; i++) {
                    const max = Math.max(...this.data[i]);
                    const exps = this.data[i].map(x => Math.exp(x - max));
                    const sum = exps.reduce((a, b) => a + b, 0);
                    result.data[i] = exps.map(x => x / sum);
                }
                return result;
            }
        }
        
        // ê°„ë‹¨í•œ Transformer ëª¨ë¸
        class SimpleTransformer {
            constructor(vocabSize, embeddingDim, numHeads) {
                this.vocabSize = vocabSize;
                this.embeddingDim = embeddingDim;
                this.numHeads = numHeads;
                
                // ì„ë² ë”© ë ˆì´ì–´
                this.embedding = new Matrix(vocabSize, embeddingDim);
                
                // ì–´í…ì…˜ ê°€ì¤‘ì¹˜
                this.wq = new Matrix(embeddingDim, embeddingDim);
                this.wk = new Matrix(embeddingDim, embeddingDim);
                this.wv = new Matrix(embeddingDim, embeddingDim);
                this.wo = new Matrix(embeddingDim, embeddingDim);
                
                // í”¼ë“œí¬ì›Œë“œ ë ˆì´ì–´
                this.w1 = new Matrix(embeddingDim, embeddingDim * 2);
                this.w2 = new Matrix(embeddingDim * 2, embeddingDim);
                
                // ì¶œë ¥ ë ˆì´ì–´
                this.outputLayer = new Matrix(embeddingDim, vocabSize);
            }
            
            forward(tokenIds) {
                // ì„ë² ë”©
                const embeddings = [];
                for (let tokenId of tokenIds) {
                    const embedding = [];
                    for (let j = 0; j < this.embeddingDim; j++) {
                        embedding.push(this.embedding.data[tokenId][j]);
                    }
                    embeddings.push(embedding);
                }
                
                // ê°„ë‹¨í•œ ì…€í”„ ì–´í…ì…˜ (ë‹¨ìˆœí™”ëœ ë²„ì „)
                const seqLen = embeddings.length;
                const attentionOutput = [];
                
                for (let i = 0; i < seqLen; i++) {
                    let weightedSum = new Array(this.embeddingDim).fill(0);
                    let totalWeight = 0;
                    
                    for (let j = 0; j < seqLen; j++) {
                        // ê°„ë‹¨í•œ ì–´í…ì…˜ ìŠ¤ì½”ì–´ ê³„ì‚°
                        let score = 0;
                        for (let k = 0; k < this.embeddingDim; k++) {
                            score += embeddings[i][k] * embeddings[j][k];
                        }
                        score = Math.exp(score / Math.sqrt(this.embeddingDim));
                        totalWeight += score;
                        
                        for (let k = 0; k < this.embeddingDim; k++) {
                            weightedSum[k] += score * embeddings[j][k];
                        }
                    }
                    
                    // ì •ê·œí™”
                    for (let k = 0; k < this.embeddingDim; k++) {
                        weightedSum[k] /= totalWeight;
                    }
                    
                    attentionOutput.push(weightedSum);
                }
                
                // ë§ˆì§€ë§‰ í† í°ì˜ ì¶œë ¥ë§Œ ì‚¬ìš© (ë‹¤ìŒ í† í° ì˜ˆì¸¡)
                const lastOutput = attentionOutput[attentionOutput.length - 1];
                
                // ì¶œë ¥ ë ˆì´ì–´
                const logits = [];
                for (let i = 0; i < this.vocabSize; i++) {
                    let sum = 0;
                    for (let j = 0; j < this.embeddingDim; j++) {
                        sum += lastOutput[j] * this.outputLayer.data[j][i];
                    }
                    logits.push(sum);
                }
                
                return logits;
            }
            
            // ê°„ë‹¨í•œ í›ˆë ¨ í•¨ìˆ˜
            train(sequences, epochs, learningRate, progressCallback) {
                for (let epoch = 0; epoch < epochs; epoch++) {
                    let totalLoss = 0;
                    
                    for (let seq of sequences) {
                        if (seq.length < 2) continue;
                        
                        for (let i = 1; i < seq.length; i++) {
                            const input = seq.slice(0, i);
                            const target = seq[i];
                            
                            const logits = this.forward(input);
                            
                            // ì†Œí”„íŠ¸ë§¥ìŠ¤
                            const max = Math.max(...logits);
                            const exps = logits.map(x => Math.exp(x - max));
                            const sum = exps.reduce((a, b) => a + b, 0);
                            const probs = exps.map(x => x / sum);
                            
                            // í¬ë¡œìŠ¤ ì—”íŠ¸ë¡œí”¼ ì†ì‹¤
                            const loss = -Math.log(probs[target] + 1e-10);
                            totalLoss += loss;
                            
                            // ê°„ë‹¨í•œ ê·¸ë˜ë””ì–¸íŠ¸ ì—…ë°ì´íŠ¸ (ì‹¤ì œë¡œëŠ” ì—­ì „íŒŒê°€ í•„ìš”)
                            // ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜ë§Œ ìˆ˜í–‰
                            for (let j = 0; j < this.vocabSize; j++) {
                                const error = (j === target ? 1 : 0) - probs[j];
                                for (let k = 0; k < this.embeddingDim; k++) {
                                    this.outputLayer.data[k][j] += learningRate * error * 0.01;
                                }
                            }
                        }
                    }
                    
                    const avgLoss = totalLoss / sequences.length;
                    progressCallback(epoch, epochs, avgLoss);
                }
            }
        }
        
        // ë°ì´í„° ì „ì²˜ë¦¬ í•¨ìˆ˜
        function preprocessData() {
            const text = document.getElementById('trainingData').value;
            
            // ë‹¨ìˆœí•œ í† í¬ë‚˜ì´ì œì´ì…˜ (ê³µë°±ê³¼ êµ¬ë‘ì  ê¸°ì¤€)
            const tokens = text.toLowerCase()
                .replace(/[^\w\sê°€-í£]/g, ' ')
                .split(/\s+/)
                .filter(token => token.length > 0);
            
            // ì–´íœ˜ì§‘ êµ¬ì¶•
            vocabulary.clear();
            reverseVocab.clear();
            let vocabIndex = 0;
            
            // íŠ¹ìˆ˜ í† í° ì¶”ê°€
            vocabulary.set('<pad>', vocabIndex++);
            vocabulary.set('<unk>', vocabIndex++);
            vocabulary.set('<start>', vocabIndex++);
            vocabulary.set('<end>', vocabIndex++);
            
            // ê³ ìœ  í† í°ë“¤ ì¶”ê°€
            const uniqueTokens = [...new Set(tokens)];
            for (let token of uniqueTokens) {
                if (!vocabulary.has(token)) {
                    vocabulary.set(token, vocabIndex++);
                }
            }
            
            // ì—­ë°©í–¥ ì–´íœ˜ì§‘ ìƒì„±
            for (let [token, id] of vocabulary) {
                reverseVocab.set(id, token);
            }
            
            // í† í°ì„ IDë¡œ ë³€í™˜
            tokenizedData = tokens.map(token => vocabulary.get(token));
            
            // ì‹œí€€ìŠ¤ ìƒì„± (ìœˆë„ìš° í¬ê¸°: 5)
            trainingData = [];
            const windowSize = 5;
            for (let i = 0; i <= tokenizedData.length - windowSize; i++) {
                trainingData.push(tokenizedData.slice(i, i + windowSize));
            }
            
            // ê²°ê³¼ ì¶œë ¥
            const output = document.getElementById('tokenizationOutput');
            output.textContent = `ì›ë³¸ í…ìŠ¤íŠ¸: ${text.substring(0, 100)}...
í† í°ë“¤: ${tokens.slice(0, 20).join(', ')}...
í† í° IDë“¤: ${tokenizedData.slice(0, 20).join(', ')}...
í›ˆë ¨ ì‹œí€€ìŠ¤ ìˆ˜: ${trainingData.length}

ì–´íœ˜ì§‘:
${Array.from(vocabulary.entries()).slice(0, 10).map(([token, id]) => `${id}: ${token}`).join('\n')}
${vocabulary.size > 10 ? '...' : ''}`;
            
            document.getElementById('vocabSize').textContent = vocabulary.size;
            document.getElementById('sequenceLength').textContent = trainingData.length;
        }
        
        // ëª¨ë¸ ì´ˆê¸°í™” í•¨ìˆ˜
        function initializeModel() {
            const embeddingDim = parseInt(document.getElementById('embeddingDim').value);
            const numHeads = parseInt(document.getElementById('numHeads').value);
            
            if (vocabulary.size === 0) {
                alert('ë¨¼ì € ë°ì´í„°ë¥¼ ì „ì²˜ë¦¬í•´ì£¼ì„¸ìš”!');
                return;
            }
            
            model = new SimpleTransformer(vocabulary.size, embeddingDim, numHeads);
            
            const output = document.getElementById('modelOutput');
            output.textContent = `ëª¨ë¸ ì•„í‚¤í…ì²˜:
- ì–´íœ˜ì§‘ í¬ê¸°: ${vocabulary.size}
- ì„ë² ë”© ì°¨ì›: ${embeddingDim}
- ì–´í…ì…˜ í—¤ë“œ ìˆ˜: ${numHeads}
- íŒŒë¼ë¯¸í„° ìˆ˜: ì•½ ${Math.round((vocabulary.size * embeddingDim + embeddingDim * embeddingDim * 4 + embeddingDim * embeddingDim * 2 + embeddingDim * vocabulary.size) / 1000)}K

ëª¨ë¸ì´ ì„±ê³µì ìœ¼ë¡œ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤!`;
            
            visualizeEmbeddings();
        }
        
        // ì„ë² ë”© ì‹œê°í™” í•¨ìˆ˜
        function visualizeEmbeddings() {
            if (!model) return;
            
            const container = document.getElementById('embeddingViz');
            container.innerHTML = '<h3>ì´ˆê¸° ì„ë² ë”© ë²¡í„° (ì²˜ìŒ 5ê°œ í† í°)</h3>';
            
            for (let i = 0; i < Math.min(5, model.vocabSize); i++) {
                const tokenDiv = document.createElement('div');
                tokenDiv.innerHTML = `<h4>í† í°: "${reverseVocab.get(i)}"</h4>`;
                
                const vectorDiv = document.createElement('div');
                vectorDiv.className = 'vector-viz';
                
                for (let j = 0; j < model.embeddingDim; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'vector-cell';
                    cell.textContent = model.embedding.data[i][j].toFixed(3);
                    vectorDiv.appendChild(cell);
                }
                
                tokenDiv.appendChild(vectorDiv);
                container.appendChild(tokenDiv);
            }
        }
        
        // ëª¨ë¸ í›ˆë ¨ í•¨ìˆ˜
        function trainModel() {
            if (!model || trainingData.length === 0) {
                alert('ë¨¼ì € ë°ì´í„° ì „ì²˜ë¦¬ì™€ ëª¨ë¸ ì´ˆê¸°í™”ë¥¼ ì™„ë£Œí•´ì£¼ì„¸ìš”!');
                return;
            }
            
            const epochs = parseInt(document.getElementById('epochs').value);
            const learningRate = parseFloat(document.getElementById('learningRate').value);
            const output = document.getElementById('trainingOutput');
            const progressBar = document.getElementById('trainingProgress');
            
            output.textContent = 'í›ˆë ¨ì„ ì‹œì‘í•©ë‹ˆë‹¤...\n';
            
            const startTime = Date.now();
            
            model.train(trainingData, epochs, learningRate, (epoch, totalEpochs, loss) => {
                const progress = ((epoch + 1) / totalEpochs) * 100;
                progressBar.style.width = progress + '%';
                
                if (epoch % 10 === 0 || epoch === totalEpochs - 1) {
                    output.textContent += `Epoch ${epoch + 1}/${totalEpochs}, Loss: ${loss.toFixed(4)}\n`;
                    output.scrollTop = output.scrollHeight;
                }
                
                if (epoch === totalEpochs - 1) {
                    const endTime = Date.now();
                    output.textContent += `\ní›ˆë ¨ ì™„ë£Œ! ì†Œìš” ì‹œê°„: ${((endTime - startTime) / 1000).toFixed(2)}ì´ˆ\n`;
                    visualizeAttention();
                    visualizeEmbeddings(); // í›ˆë ¨ í›„ ì„ë² ë”© ì—…ë°ì´íŠ¸
                }
            });
        }
        
        // ì–´í…ì…˜ ì‹œê°í™” í•¨ìˆ˜
        function visualizeAttention() {
            const container = document.getElementById('attentionViz');
            container.innerHTML = '<h3>ì–´í…ì…˜ íŒ¨í„´ ì‹œë®¬ë ˆì´ì…˜</h3>';
            
            // ê°„ë‹¨í•œ ì–´í…ì…˜ íŒ¨í„´ ì‹œë®¬ë ˆì´ì…˜
            const seqLen = 8;
            const attentionDiv = document.createElement('div');
            attentionDiv.className = 'attention-viz';
            
            for (let i = 0; i < seqLen; i++) {
                for (let j = 0; j < seqLen; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'attention-cell';
                    
                    // ê°„ë‹¨í•œ ì–´í…ì…˜ ìŠ¤ì½”ì–´ ì‹œë®¬ë ˆì´ì…˜
                    const score = Math.exp(-Math.abs(i - j) * 0.5) + Math.random() * 0.3;
                    const intensity = Math.min(score, 1);
                    
                    cell.style.backgroundColor = `rgba(102, 126, 234, ${intensity})`;
                    cell.textContent = intensity.toFixed(2);
                    
                    attentionDiv.appendChild(cell);
                }
            }
            
            container.appendChild(attentionDiv);
            
            const legend = document.createElement('p');
            legend.textContent = 'ì–´í…ì…˜ ê°•ë„: ì§„í•œ íŒŒë‘ìƒ‰ì¼ìˆ˜ë¡ ë†’ì€ ì–´í…ì…˜ (í† í° ê°„ ê´€ë ¨ì„±)';
            container.appendChild(legend);
        }
        
        // í…ìŠ¤íŠ¸ ìƒì„± í•¨ìˆ˜
        function generateText() {
            if (!model) {
                alert('ë¨¼ì € ëª¨ë¸ì„ í›ˆë ¨í•´ì£¼ì„¸ìš”!');
                return;
            }
            
            const seedText = document.getElementById('seedText').value.toLowerCase();
            const generateLength = parseInt(document.getElementById('generateLength').value);
            const output = document.getElementById('generationOutput');
            
            // ì‹œë“œ í…ìŠ¤íŠ¸ í† í¬ë‚˜ì´ì§•
            const seedTokens = seedText.split(/\s+/).filter(token => token.length > 0);
            let currentSequence = seedTokens.map(token => 
                vocabulary.has(token) ? vocabulary.get(token) : vocabulary.get('<unk>')
            );
            
            let generatedText = seedText;
            output.textContent = `ì‹œë“œ í…ìŠ¤íŠ¸: "${seedText}"\nìƒì„± ê³¼ì •:\n\n`;
            
            for (let i = 0; i < generateLength; i++) {
                // ë‹¤ìŒ í† í° ì˜ˆì¸¡
                const logits = model.forward(currentSequence);
                
                // ì†Œí”„íŠ¸ë§¥ìŠ¤ ì ìš©
                const max = Math.max(...logits);
                const exps = logits.map(x => Math.exp(x - max));
                const sum = exps.reduce((a, b) => a + b, 0);
                const probs = exps.map(x => x / sum);
                
                // ìƒìœ„ 3ê°œ í›„ë³´ í‘œì‹œ
                const topIndices = probs
                    .map((prob, idx) => ({prob, idx}))
                    .sort((a, b) => b.prob - a.prob)
                    .slice(0, 3);
                
                output.textContent += `Step ${i + 1}:\n`;
                output.textContent += `ìƒìœ„ í›„ë³´ë“¤:\n`;
                for (let candidate of topIndices) {
                    const token = reverseVocab.get(candidate.idx);
                    output.textContent += `  "${token}": ${(candidate.prob * 100).toFixed(2)}%\n`;
                }
                
                // ê°€ì¥ ë†’ì€ í™•ë¥ ì˜ í† í° ì„ íƒ (ë˜ëŠ” ìƒ˜í”Œë§)
                const nextTokenId = topIndices[0].idx;
                const nextToken = reverseVocab.get(nextTokenId);
                
                generatedText += ' ' + nextToken;
                currentSequence.push(nextTokenId);
                
                // ì‹œí€€ìŠ¤ ê¸¸ì´ ì œí•œ (ë©”ëª¨ë¦¬ ì ˆì•½)
                if (currentSequence.length > 10) {
                    currentSequence = currentSequence.slice(-10);
                }
                
                output.textContent += `ì„ íƒëœ í† í°: "${nextToken}"\n`;
                output.textContent += `í˜„ì¬ í…ìŠ¤íŠ¸: "${generatedText}"\n\n`;
                output.scrollTop = output.scrollHeight;
            }
            
            output.textContent += `\nìµœì¢… ìƒì„±ëœ í…ìŠ¤íŠ¸:\n"${generatedText}"`;
        }
        
        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
        console.log('Simple LLM Demo ì¤€ë¹„ ì™„ë£Œ!');
    </script>
</body>
</html>
