<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple LLM Demo</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .section {
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 15px;
            border-left: 5px solid #667eea;
        }
        
        .section h2 {
            color: #2c3e50;
            margin-bottom: 15px;
        }
        
        .input-group {
            margin: 15px 0;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #34495e;
        }
        
        textarea, input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
            box-sizing: border-box;
        }
        
        textarea:focus, input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
            transition: transform 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .output {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
            margin: 10px 0;
        }
        
        .vector-viz {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(40px, 1fr));
            gap: 5px;
            margin: 10px 0;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .vector-cell {
            background: #3498db;
            color: white;
            padding: 5px;
            text-align: center;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #ecf0f1;
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            transition: width 0.3s;
            border-radius: 10px;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .metric-card {
            background: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¤– Simple LLM Implementation</h1>
        
        <div class="section">
            <h2>ğŸ“š 1. í›ˆë ¨ ë°ì´í„° ì…ë ¥</h2>
            <div class="input-group">
                <label>í›ˆë ¨í•  í…ìŠ¤íŠ¸ ë°ì´í„°:</label>
                <textarea id="trainingData" rows="6" placeholder="í›ˆë ¨í•  í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”.">ì•ˆë…•í•˜ì„¸ìš”. ì €ëŠ” AIì…ë‹ˆë‹¤. AIëŠ” ì¸ê³µì§€ëŠ¥ì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ì¸ê³µì§€ëŠ¥ì€ ì»´í“¨í„°ê°€ ì‚¬ëŒì²˜ëŸ¼ ìƒê°í•˜ê³  í•™ìŠµí•˜ëŠ” ê¸°ìˆ ì…ë‹ˆë‹¤. ê¸°ìˆ ì€ ìš°ë¦¬ ì‚¶ì„ í¸ë¦¬í•˜ê²Œ ë§Œë“­ë‹ˆë‹¤. ì‚¶ì€ ì†Œì¤‘í•©ë‹ˆë‹¤. ì†Œì¤‘í•œ ê²ƒë“¤ì„ ì§€ì¼œì•¼ í•©ë‹ˆë‹¤.</textarea>
            </div>
            <button onclick="preprocessData()">ë°ì´í„° ì „ì²˜ë¦¬ ì‹œì‘</button>
        </div>
        
        <div class="section">
            <h2>ğŸ”¤ 2. í† í¬ë‚˜ì´ì œì´ì…˜ & ì–´íœ˜ì§‘ êµ¬ì¶•</h2>
            <div class="output" id="tokenizationOutput">ë°ì´í„°ë¥¼ ì „ì²˜ë¦¬í•˜ë©´ í† í°í™” ê²°ê³¼ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</div>
            <div class="metrics">
                <div class="metric-card">
                    <div class="metric-value" id="vocabSize">0</div>
                    <div>ì–´íœ˜ì§‘ í¬ê¸°</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="sequenceLength">0</div>
                    <div>ì‹œí€€ìŠ¤ ê¸¸ì´</div>
                </div>
            </div>
        </div>
        
        <div class="section">
            <h2>ğŸ§  3. ëª¨ë¸ ì•„í‚¤í…ì²˜ ì´ˆê¸°í™”</h2>
            <div class="input-group">
                <label>ì„ë² ë”© ì°¨ì›:</label>
                <input type="number" id="embeddingDim" value="32" min="16" max="128">
            </div>
            <div class="input-group">
                <label>ì–´í…ì…˜ í—¤ë“œ ìˆ˜:</label>
                <input type="number" id="numHeads" value="4" min="1" max="8">
            </div>
            <button onclick="initializeModel()">ëª¨ë¸ ì´ˆê¸°í™”</button>
            <div class="output" id="modelOutput">ëª¨ë¸ì„ ì´ˆê¸°í™”í•˜ë©´ ì•„í‚¤í…ì²˜ ì •ë³´ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</div>
        </div>
        
        <div class="section">
            <h2>ğŸ“Š 4. ë²¡í„° ê³µê°„ ì‹œê°í™”</h2>
            <div id="embeddingViz">
                <p>ëª¨ë¸ì„ ì´ˆê¸°í™”í•˜ë©´ ì„ë² ë”© ë²¡í„°ë“¤ì´ ì—¬ê¸°ì— ì‹œê°í™”ë©ë‹ˆë‹¤.</p>
            </div>
        </div>
        
        <div class="section">
            <h2>ğŸƒâ€â™‚ï¸ 5. ëª¨ë¸ í›ˆë ¨</h2>
            <div class="input-group">
                <label>ì—í¬í¬ ìˆ˜:</label>
                <input type="number" id="epochs" value="50" min="10" max="200">
            </div>
            <div class="input-group">
                <label>í•™ìŠµë¥ :</label>
                <input type="number" id="learningRate" value="0.01" step="0.001" min="0.001" max="0.1">
            </div>
            <button onclick="trainModel()">í›ˆë ¨ ì‹œì‘</button>
            <div class="progress-bar">
                <div class="progress-fill" id="trainingProgress" style="width: 0%"></div>
            </div>
            <div class="output" id="trainingOutput">í›ˆë ¨ì„ ì‹œì‘í•˜ë©´ ì†ì‹¤ê°’ê³¼ ì§„í–‰ìƒí™©ì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</div>
        </div>
        
        <div class="section">
            <h2>ğŸ” 6. ì–´í…ì…˜ ì‹œê°í™”</h2>
            <div id="attentionViz">
                <p>í›ˆë ¨ í›„ ì–´í…ì…˜ íŒ¨í„´ì´ ì—¬ê¸°ì— ì‹œê°í™”ë©ë‹ˆë‹¤.</p>
            </div>
        </div>
        
        <div class="section">
            <h2>ğŸ’­ 7. ì¶”ë¡  í…ŒìŠ¤íŠ¸</h2>
            <div class="input-group">
                <label>ì‹œì‘ í…ìŠ¤íŠ¸:</label>
                <input type="text" id="seedText" placeholder="ì˜ˆ: ì•ˆë…•" value="ì•ˆë…•">
            </div>
            <div class="input-group">
                <label>ìƒì„±í•  í† í° ìˆ˜:</label>
                <input type="number" id="generateLength" value="10" min="1" max="50">
            </div>
            <button onclick="generateText()">í…ìŠ¤íŠ¸ ìƒì„±</button>
            <div class="output" id="generationOutput">ìƒì„±ëœ í…ìŠ¤íŠ¸ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</div>
        </div>
    </div>

    <script>
        // ì „ì—­ ë³€ìˆ˜ë“¤
        let vocabulary = new Map();
        let reverseVocab = new Map();
        let tokenizedData = [];
        let model = null;
        let trainingData = [];
        
        // ê°„ë‹¨í•œ Matrix í´ë˜ìŠ¤
        class Matrix {
            constructor(rows, cols, values = null) {
                this.rows = rows;
                this.cols = cols;
                this.data = values || Array(rows).fill().map(() => 
                    Array(cols).fill().map(() => (Math.random() - 0.5) * 0.1)
                );
            }
            
            multiply(other) {
                if (this.cols !== other.rows) {
                    throw new Error("Matrix dimensions don't match");
                }
                const result = new Matrix(this.rows, other.cols);
                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < other.cols; j++) {
                        result.data[i][j] = 0;
                        for (let k = 0; k < this.cols; k++) {
                            result.data[i][j] += this.data[i][k] * other.data[k][j];
                        }
                    }
                }
                return result;
            }
        }
        
        // ê°„ë‹¨í•œ Transformer ëª¨ë¸
        class SimpleTransformer {
            constructor(vocabSize, embeddingDim, numHeads) {
                this.vocabSize = vocabSize;
                this.embeddingDim = embeddingDim;
                this.numHeads = numHeads;
                
                // ì„ë² ë”© ë ˆì´ì–´
                this.embedding = new Matrix(vocabSize, embeddingDim);
                
                // ì¶œë ¥ ë ˆì´ì–´
                this.outputLayer = new Matrix(embeddingDim, vocabSize);
            }
            
            forward(tokenIds) {
                // ì„ë² ë”©
                const embeddings = [];
                for (let tokenId of tokenIds) {
                    const embedding = [];
                    for (let j = 0; j < this.embeddingDim; j++) {
                        embedding.push(this.embedding.data[tokenId][j]);
                    }
                    embeddings.push(embedding);
                }
                
                // ê°„ë‹¨í•œ ì…€í”„ ì–´í…ì…˜
                const seqLen = embeddings.length;
                const attentionOutput = [];
                
                for (let i = 0; i < seqLen; i++) {
                    let weightedSum = new Array(this.embeddingDim).fill(0);
                    let totalWeight = 0;
                    
                    for (let j = 0; j < seqLen; j++) {
                        let score = 0;
                        for (let k = 0; k < this.embeddingDim; k++) {
                            score += embeddings[i][k] * embeddings[j][k];
                        }
                        score = Math.exp(score / Math.sqrt(this.embeddingDim));
                        totalWeight += score;
                        
                        for (let k = 0; k < this.embeddingDim; k++) {
                            weightedSum[k] += score * embeddings[j][k];
                        }
                    }
                    
                    for (let k = 0; k < this.embeddingDim; k++) {
                        weightedSum[k] /= totalWeight;
                    }
                    
                    attentionOutput.push(weightedSum);
                }
                
                // ë§ˆì§€ë§‰ í† í°ì˜ ì¶œë ¥ë§Œ ì‚¬ìš©
                const lastOutput = attentionOutput[attentionOutput.length - 1];
                
                // ì¶œë ¥ ë ˆì´ì–´
                const logits = [];
                for (let i = 0; i < this.vocabSize; i++) {
                    let sum = 0;
                    for (let j = 0; j < this.embeddingDim; j++) {
                        sum += lastOutput[j] * this.outputLayer.data[j][i];
                    }
                    logits.push(sum);
                }
                
                return logits;
            }
            
            train(sequences, epochs, learningRate, progressCallback) {
                for (let epoch = 0; epoch < epochs; epoch++) {
                    let totalLoss = 0;
                    let stepCount = 0;
                    let detailedLog = '';
                    
                    for (let seqIdx = 0; seqIdx < sequences.length; seqIdx++) {
                        const seq = sequences[seqIdx];
                        if (seq.length < 2) continue;
                        
                        for (let i = 1; i < seq.length; i++) {
                            const input = seq.slice(0, i);
                            const target = seq[i];
                            
                            const logits = this.forward(input);
                            
                            // ì†Œí”„íŠ¸ë§¥ìŠ¤
                            const max = Math.max(...logits);
                            const exps = logits.map(x => Math.exp(x - max));
                            const sum = exps.reduce((a, b) => a + b, 0);
                            const probs = exps.map(x => x / sum);
                            
                            // í¬ë¡œìŠ¤ ì—”íŠ¸ë¡œí”¼ ì†ì‹¤
                            const loss = -Math.log(probs[target] + 1e-10);
                            totalLoss += loss;
                            stepCount++;
                            
                            // ì²˜ìŒ ëª‡ ìŠ¤í…ì˜ ìƒì„¸ ë¡œê·¸
                            if (epoch < 2 && stepCount <= 5) {
                                const inputTokens = input.map(id => reverseVocab.get(id)).join(' ');
                                const targetToken = reverseVocab.get(target);
                                const topProbs = probs
                                    .map((prob, idx) => ({prob, token: reverseVocab.get(idx)}))
                                    .sort((a, b) => b.prob - a.prob)
                                    .slice(0, 3);
                                
                                detailedLog += `\n      ìŠ¤í… ${stepCount}: "${inputTokens}" â†’ "${targetToken}"`;
                                detailedLog += `\n                  ì˜ˆì¸¡í™•ë¥ : ${topProbs.map(p => `"${p.token}":${(p.prob*100).toFixed(1)}%`).join(', ')}`;
                                detailedLog += `\n                  ì†ì‹¤: ${loss.toFixed(4)}`;
                                detailedLog += `\n                  ì •ë‹µí™•ë¥ : ${(probs[target]*100).toFixed(1)}%`;
                            }
                            
                            // ë” ê°•í•œ ê·¸ë˜ë””ì–¸íŠ¸ ì—…ë°ì´íŠ¸ë¡œ í•™ìŠµ ê°œì„ 
                            for (let j = 0; j < this.vocabSize; j++) {
                                const error = (j === target ? 1 : 0) - probs[j];
                                for (let k = 0; k < this.embeddingDim; k++) {
                                    // ì„ë² ë”©ê³¼ ì¶œë ¥ ë ˆì´ì–´ ëª¨ë‘ ì—…ë°ì´íŠ¸
                                    this.outputLayer.data[k][j] += learningRate * error * 0.1;
                                    
                                    // ì…ë ¥ í† í°ë“¤ì˜ ì„ë² ë”©ë„ ì—…ë°ì´íŠ¸
                                    for (let inputToken of input) {
                                        this.embedding.data[inputToken][k] += learningRate * error * 0.01;
                                    }
                                }
                            }
                        }
                    }
                    
                    const avgLoss = totalLoss / stepCount;
                    progressCallback(epoch, epochs, avgLoss, detailedLog);
                }
            }
        }
        
        // ë°ì´í„° ì „ì²˜ë¦¬ í•¨ìˆ˜
        function preprocessData() {
            const text = document.getElementById('trainingData').value;
            
            // í† í¬ë‚˜ì´ì œì´ì…˜
            const tokens = text.toLowerCase()
                .replace(/[^\w\sê°€-í£]/g, ' ')
                .split(/\s+/)
                .filter(token => token.length > 0);
            
            // ì–´íœ˜ì§‘ êµ¬ì¶•
            vocabulary.clear();
            reverseVocab.clear();
            let vocabIndex = 0;
            
            // íŠ¹ìˆ˜ í† í° ì¶”ê°€
            vocabulary.set('<pad>', vocabIndex++);
            vocabulary.set('<unk>', vocabIndex++);
            vocabulary.set('<start>', vocabIndex++);
            vocabulary.set('<end>', vocabIndex++);
            
            // ê³ ìœ  í† í°ë“¤ ì¶”ê°€
            const uniqueTokens = [...new Set(tokens)];
            for (let token of uniqueTokens) {
                if (!vocabulary.has(token)) {
                    vocabulary.set(token, vocabIndex++);
                }
            }
            
            // ì—­ë°©í–¥ ì–´íœ˜ì§‘ ìƒì„±
            for (let [token, id] of vocabulary) {
                reverseVocab.set(id, token);
            }
            
            // í† í°ì„ IDë¡œ ë³€í™˜
            tokenizedData = tokens.map(token => vocabulary.get(token));
            
            // ì‹œí€€ìŠ¤ ìƒì„±
            trainingData = [];
            const windowSize = 5;
            for (let i = 0; i <= tokenizedData.length - windowSize; i++) {
                trainingData.push(tokenizedData.slice(i, i + windowSize));
            }
            
            // ìƒì„¸í•œ ê²°ê³¼ ì¶œë ¥
            const output = document.getElementById('tokenizationOutput');
            output.textContent = `ğŸ“ ì›ë³¸ í…ìŠ¤íŠ¸:\n${text}\n\nğŸ”¤ ëª¨ë“  í† í°ë“¤:\n${tokens.join(', ')}\n\nğŸ”¢ í† í° ID ë³€í™˜:\n${tokens.map((token, i) => `"${token}" â†’ ${vocabulary.get(token)}`).join('\n')}\n\nğŸ“š ì „ì²´ ì–´íœ˜ì§‘ (Vocabulary):\n${Array.from(vocabulary.entries()).map(([token, id]) => `${id}: "${token}"`).join('\n')}\n\nğŸ”— ìƒì„±ëœ í›ˆë ¨ ì‹œí€€ìŠ¤ë“¤:\n${trainingData.map((seq, i) => `ì‹œí€€ìŠ¤ ${i + 1}: [${seq.join(', ')}] â†’ (${seq.slice(0, -1).map(id => `"${reverseVocab.get(id)}"`).join(' ')} â†’ "${reverseVocab.get(seq[seq.length - 1])}")`).join('\n')}\n\nğŸ“Š í†µê³„:\n- ì´ í† í° ìˆ˜: ${tokens.length}\n- ê³ ìœ  í† í° ìˆ˜: ${uniqueTokens.length}\n- ì–´íœ˜ì§‘ í¬ê¸°: ${vocabulary.size} (íŠ¹ìˆ˜í† í° 4ê°œ í¬í•¨)\n- í›ˆë ¨ ì‹œí€€ìŠ¤ ìˆ˜: ${trainingData.length}`;
            
            document.getElementById('vocabSize').textContent = vocabulary.size;
            document.getElementById('sequenceLength').textContent = trainingData.length;
        }
        
        // ëª¨ë¸ ì´ˆê¸°í™” í•¨ìˆ˜
        function initializeModel() {
            const embeddingDim = parseInt(document.getElementById('embeddingDim').value);
            const numHeads = parseInt(document.getElementById('numHeads').value);
            
            if (vocabulary.size === 0) {
                alert('ë¨¼ì € ë°ì´í„°ë¥¼ ì „ì²˜ë¦¬í•´ì£¼ì„¸ìš”!');
                return;
            }
            
            model = new SimpleTransformer(vocabulary.size, embeddingDim, numHeads);
            
            const output = document.getElementById('modelOutput');
            output.textContent = `ëª¨ë¸ ì•„í‚¤í…ì²˜:\n- ì–´íœ˜ì§‘ í¬ê¸°: ${vocabulary.size}\n- ì„ë² ë”© ì°¨ì›: ${embeddingDim}\n- ì–´í…ì…˜ í—¤ë“œ ìˆ˜: ${numHeads}\n- íŒŒë¼ë¯¸í„° ìˆ˜: ì•½ ${Math.round((vocabulary.size * embeddingDim + embeddingDim * vocabulary.size) / 1000)}K\n\nëª¨ë¸ì´ ì„±ê³µì ìœ¼ë¡œ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤!`;
            
            visualizeEmbeddings();
        }
        
        // ì„ë² ë”© ì‹œê°í™” í•¨ìˆ˜
        function visualizeEmbeddings() {
            if (!model) return;
            
            const container = document.getElementById('embeddingViz');
            container.innerHTML = '<h3>ğŸ¯ ëª¨ë“  í† í°ì˜ ì„ë² ë”© ë²¡í„°</h3>';
            
            for (let i = 0; i < model.vocabSize; i++) {
                const tokenDiv = document.createElement('div');
                tokenDiv.style.marginBottom = '20px';
                tokenDiv.style.border = '1px solid #ddd';
                tokenDiv.style.borderRadius = '8px';
                tokenDiv.style.padding = '10px';
                tokenDiv.style.backgroundColor = '#f9f9f9';
                
                const tokenName = reverseVocab.get(i);
                const isSpecialToken = tokenName.startsWith('<') && tokenName.endsWith('>');
                
                tokenDiv.innerHTML = `<h4 style="margin: 0 0 10px 0; color: ${isSpecialToken ? '#e74c3c' : '#2c3e50'};">í† í° ID ${i}: "${tokenName}" ${isSpecialToken ? '(íŠ¹ìˆ˜í† í°)' : ''}</h4>`;
                
                const vectorDiv = document.createElement('div');
                vectorDiv.className = 'vector-viz';
                vectorDiv.style.marginBottom = '10px';
                
                let vectorSum = 0;
                for (let j = 0; j < model.embeddingDim; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'vector-cell';
                    const value = model.embedding.data[i][j];
                    cell.textContent = value.toFixed(3);
                    
                    const intensity = Math.abs(value);
                    const hue = value > 0 ? 120 : 0;
                    cell.style.backgroundColor = `hsla(${hue}, 70%, 50%, ${Math.min(intensity * 10, 1)})`;
                    
                    vectorDiv.appendChild(cell);
                    vectorSum += value * value;
                }
                
                const magnitude = Math.sqrt(vectorSum);
                const statsDiv = document.createElement('div');
                statsDiv.style.fontSize = '12px';
                statsDiv.style.color = '#666';
                statsDiv.innerHTML = `ë²¡í„° í¬ê¸°(L2 norm): ${magnitude.toFixed(4)} | í‰ê· ê°’: ${(vectorSum / model.embeddingDim).toFixed(4)}`;
                
                tokenDiv.appendChild(vectorDiv);
                tokenDiv.appendChild(statsDiv);
                container.appendChild(tokenDiv);
            }
        }
        
        // ëª¨ë¸ í›ˆë ¨ í•¨ìˆ˜
        function trainModel() {
            if (!model || trainingData.length === 0) {
                alert('ë¨¼ì € ë°ì´í„° ì „ì²˜ë¦¬ì™€ ëª¨ë¸ ì´ˆê¸°í™”ë¥¼ ì™„ë£Œí•´ì£¼ì„¸ìš”!');
                return;
            }
            
            const epochs = parseInt(document.getElementById('epochs').value);
            const learningRate = parseFloat(document.getElementById('learningRate').value);
            const output = document.getElementById('trainingOutput');
            const progressBar = document.getElementById('trainingProgress');
            
            output.textContent = `ğŸš€ í›ˆë ¨ ì‹œì‘!\nğŸ“Š ì„¤ì •ê°’:\n- ì—í¬í¬: ${epochs}\n- í•™ìŠµë¥ : ${learningRate}\n- í›ˆë ¨ ì‹œí€€ìŠ¤ ìˆ˜: ${trainingData.length}\n\nğŸ“ ìƒì„¸ í›ˆë ¨ ê³¼ì •:\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n`;
            
            const startTime = Date.now();
            
            model.train(trainingData, epochs, learningRate, (epoch, totalEpochs, loss, detailedLog) => {
                const progress = ((epoch + 1) / totalEpochs) * 100;
                progressBar.style.width = progress + '%';
                
                output.textContent += `ğŸ“ˆ Epoch ${epoch + 1}/${totalEpochs}:\n   í‰ê·  ì†ì‹¤: ${loss.toFixed(6)}\n   ì§„í–‰ë¥ : ${progress.toFixed(1)}%\n`;
                
                if (epoch < 3 || epoch % 10 === 0 || epoch === totalEpochs - 1) {
                    if (detailedLog) {
                        output.textContent += `   ìƒì„¸ ë¡œê·¸: ${detailedLog}\n`;
                    }
                }
                
                output.textContent += '\n';
                output.scrollTop = output.scrollHeight;
                
                if (epoch === totalEpochs - 1) {
                    const endTime = Date.now();
                    output.textContent += `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nğŸ‰ í›ˆë ¨ ì™„ë£Œ!\nâ±ï¸  ì´ ì†Œìš” ì‹œê°„: ${((endTime - startTime) / 1000).toFixed(2)}ì´ˆ\nğŸ“‰ ìµœì¢… ì†ì‹¤: ${loss.toFixed(6)}\n\nğŸ”„ ì„ë² ë”© ë²¡í„°ì™€ ì–´í…ì…˜ íŒ¨í„´ì„ ì—…ë°ì´íŠ¸ ì¤‘...`;
                    
                    setTimeout(() => {
                        visualizeAttention();
                        visualizeEmbeddings();
                        output.textContent += '\nâœ… ëª¨ë“  ì‹œê°í™” ì—…ë°ì´íŠ¸ ì™„ë£Œ!';
                    }, 100);
                }
            });
        }
        
        // ì–´í…ì…˜ ì‹œê°í™” í•¨ìˆ˜
        function visualizeAttention() {
            const container = document.getElementById('attentionViz');
            container.innerHTML = '<h3>ğŸ” ì–´í…ì…˜ íŒ¨í„´ ìƒì„¸ ë¶„ì„</h3>';
            
            if (trainingData.length > 0) {
                const sampleSequence = trainingData[0];
                const seqLen = sampleSequence.length;
                
                const embeddings = [];
                for (let tokenId of sampleSequence) {
                    const embedding = [];
                    for (let j = 0; j < model.embeddingDim; j++) {
                        embedding.push(model.embedding.data[tokenId][j]);
                    }
                    embeddings.push(embedding);
                }
                
                const attentionMatrix = [];
                for (let i = 0; i < seqLen; i++) {
                    const row = [];
                    for (let j = 0; j < seqLen; j++) {
                        let score = 0;
                        for (let k = 0; k < model.embeddingDim; k++) {
                            score += embeddings[i][k] * embeddings[j][k];
                        }
                        score = score / Math.sqrt(model.embeddingDim);
                        row.push(score);
                    }
                    attentionMatrix.push(row);
                }
                
                const attentionWeights = [];
                for (let i = 0; i < seqLen; i++) {
                    const max = Math.max(...attentionMatrix[i]);
                    const exps = attentionMatrix[i].map(x => Math.exp(x - max));
                    const sum = exps.reduce((a, b) => a + b, 0);
                    attentionWeights.push(exps.map(x => x / sum));
                }
                
                const seqInfo = document.createElement('div');
                seqInfo.innerHTML = `<h4>ğŸ“Š ë¶„ì„ ëŒ€ìƒ ì‹œí€€ìŠ¤:</h4><p><strong>í† í°ë“¤:</strong> ${sampleSequence.map(id => `"${reverseVocab.get(id)}"`).join(' â†’ ')}</p><p><strong>í† í° ID:</strong> [${sampleSequence.join(', ')}]</p>`;
                container.appendChild(seqInfo);
                
                const matrixDiv = document.createElement('div');
                matrixDiv.innerHTML = '<h4>ğŸ¯ ì–´í…ì…˜ ê°€ì¤‘ì¹˜ ë§¤íŠ¸ë¦­ìŠ¤:</h4>';
                
                const attentionGrid = document.createElement('div');
                attentionGrid.style.display = 'grid';
                attentionGrid.style.gridTemplateColumns = `80px repeat(${seqLen}, 60px)`;
                attentionGrid.style.gap = '2px';
                attentionGrid.style.margin = '10px 0';
                
                const emptyHeader = document.createElement('div');
                emptyHeader.style.padding = '5px';
                emptyHeader.style.fontWeight = 'bold';
                emptyHeader.style.textAlign = 'center';
                emptyHeader.textContent = 'Query\\Key';
                attentionGrid.appendChild(emptyHeader);
                
                for (let j = 0; j < seqLen; j++) {
                    const header = document.createElement('div');
                    header.style.padding = '5px';
                    header.style.fontWeight = 'bold';
                    header.style.textAlign = 'center';
                    header.style.backgroundColor = '#e3f2fd';
                    header.style.fontSize = '12px';
                    header.textContent = reverseVocab.get(sampleSequence[j]);
                    attentionGrid.appendChild(header);
                }
                
                for (let i = 0; i < seqLen; i++) {
                    const rowHeader = document.createElement('div');
                    rowHeader.style.padding = '5px';
                    rowHeader.style.fontWeight = 'bold';
                    rowHeader.style.textAlign = 'center';
                    rowHeader.style.backgroundColor = '#fff3e0';
                    rowHeader.style.fontSize = '12px';
                    rowHeader.textContent = reverseVocab.get(sampleSequence[i]);
                    attentionGrid.appendChild(rowHeader);
                    
                    for (let j = 0; j < seqLen; j++) {
                        const cell = document.createElement('div');
                        cell.style.padding = '8px 4px';
                        cell.style.textAlign = 'center';
                        cell.style.fontSize = '11px';
                        cell.style.borderRadius = '3px';
                        cell.style.color = 'white';
                        cell.style.fontWeight = 'bold';
                        
                        const weight = attentionWeights[i][j];
                        const intensity = weight;
                        
                        if (i === j) {
                            cell.style.backgroundColor = `rgba(255, 152, 0, ${intensity})`;
                        } else {
                            cell.style.backgroundColor = `rgba(102, 126, 234, ${intensity})`;
                        }
                        
                        cell.textContent = weight.toFixed(3);
                        cell.title = `"${reverseVocab.get(sampleSequence[i])}" â†’ "${reverseVocab.get(sampleSequence[j])}"`;
                        
                        attentionGrid.appendChild(cell);
                    }
                }
                
                matrixDiv.appendChild(attentionGrid);
                container.appendChild(matrixDiv);
                
                const analysisDiv = document.createElement('div');
                analysisDiv.innerHTML = '<h4>ğŸ“ˆ ì–´í…ì…˜ íŒ¨í„´ ë¶„ì„:</h4>';
                
                let analysisText = '';
                for (let i = 0; i < seqLen; i++) {
                    const queryToken = reverseVocab.get(sampleSequence[i]);
                    const weights = attentionWeights[i];
                    const maxIdx = weights.indexOf(Math.max(...weights));
                    const keyToken = reverseVocab.get(sampleSequence[maxIdx]);
                    const maxWeight = weights[maxIdx];
                    
                    analysisText += `â€¢ "${queryToken}"ê°€ ê°€ì¥ ì£¼ëª©í•˜ëŠ” í† í°: "${keyToken}" (${(maxWeight * 100).toFixed(1)}%)\n`;
                    
                    const otherAttentions = weights
                        .map((w, idx) => ({weight: w, token: reverseVocab.get(sampleSequence[idx]), idx}))
                        .filter((item, idx) => idx !== i && item.weight > 0.1)
                        .sort((a, b) => b.weight - a.weight);
                    
                    if (otherAttentions.length > 0) {
                        analysisText += `  ê´€ë ¨ í† í°ë“¤: ${otherAttentions.slice(0, 2).map(item => `"${item.token}"(${(item.weight * 100).toFixed(1)}%)`).join(', ')}\n`;
                    }
                }
                
                const analysisContent = document.createElement('pre');
                analysisContent.style.backgroundColor = '#f8f9fa';
                analysisContent.style.padding = '15px';
                analysisContent.style.borderRadius = '5px';
                analysisContent.style.fontSize = '14px';
                analysisContent.style.lineHeight = '1.5';
                analysisContent.textContent = analysisText;
                
                analysisDiv.appendChild(analysisContent);
                container.appendChild(analysisDiv);
                
            } else {
                container.innerHTML += '<p>í›ˆë ¨ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
            }
            
            const legend = document.createElement('div');
            legend.innerHTML = `<h4>ğŸ¨ ë²”ë¡€:</h4>
<div style="display: flex; gap: 20px; margin-top: 10px;">
    <div style="display: flex; align-items: center; gap: 5px;">
        <div style="width: 20px; height: 20px; background-color: rgba(102, 126, 234, 0.8); border-radius: 3px;"></div>
        <span>ë‹¤ë¥¸ í† í°ì— ëŒ€í•œ ì–´í…ì…˜</span>
    </div>
    <div style="display: flex; align-items: center; gap: 5px;">
        <div style="width: 20px; height: 20px; background-color: rgba(255, 152, 0, 0.8); border-radius: 3px;"></div>
        <span>ìê¸° ìì‹ ì— ëŒ€í•œ ì–´í…ì…˜</span>
    </div>
</div>
<p style="margin-top: 10px; font-size: 14px; color: #666;">
ğŸ’¡ <strong>í•´ì„:</strong> ì–´í…ì…˜ ê°€ì¤‘ì¹˜ê°€ ë†’ì„ìˆ˜ë¡ í•´ë‹¹ í† í°ë“¤ ê°„ì˜ ê´€ë ¨ì„±ì´ ë†’ìŠµë‹ˆë‹¤. 
ê° Query í† í°ì´ ì–´ë–¤ Key í† í°ë“¤ì— ì£¼ëª©í•˜ëŠ”ì§€ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
</p>`;
            container.appendChild(legend);
        }
        
        // í…ìŠ¤íŠ¸ ìƒì„± í•¨ìˆ˜
        function generateText() {
            if (!model) {
                alert('ë¨¼ì € ëª¨ë¸ì„ í›ˆë ¨í•´ì£¼ì„¸ìš”!');
                return;
            }
            
            const seedText = document.getElementById('seedText').value.toLowerCase();
            const generateLength = parseInt(document.getElementById('generateLength').value);
            const output = document.getElementById('generationOutput');
            
            const seedTokens = seedText.split(/\s+/).filter(token => token.length > 0);
            let currentSequence = seedTokens.map(token => 
                vocabulary.has(token) ? vocabulary.get(token) : vocabulary.get('<unk>')
            );
            
            let generatedText = seedText;
            
            // ë¨¼ì € ê°„ë‹¨í•œ ê²°ê³¼ë¶€í„° ë³´ì—¬ì£¼ê¸°
            output.textContent = `ğŸ¯ "${seedText}" ë‹¤ìŒì— ì˜¬ ë‹¨ì–´ ì˜ˆì¸¡ ê²°ê³¼:\n\n`;
            
            // ì²« ë²ˆì§¸ ì˜ˆì¸¡ë§Œ ë°”ë¡œ ë³´ì—¬ì£¼ê¸°
            const firstLogits = model.forward(currentSequence);
            const firstMax = Math.max(...firstLogits);
            const firstExps = firstLogits.map(x => Math.exp(x - firstMax));
            const firstSum = firstExps.reduce((a, b) => a + b, 0);
            const firstProbs = firstExps.map(x => x / firstSum);
            
            const firstCandidates = firstProbs
                .map((prob, idx) => ({prob, idx, token: reverseVocab.get(idx)}))
                .sort((a, b) => b.prob - a.prob);
            
            const topFirst = firstCandidates[0];
            output.textContent += `ğŸ† ê°€ì¥ ê°€ëŠ¥ì„± ë†’ì€ ë‹¤ìŒ ë‹¨ì–´: "${topFirst.token}" (${(topFirst.prob * 100).toFixed(1)}% í™•ë¥ )\n\n`;
            output.textContent += `ğŸ“Š ìƒìœ„ 5ê°œ í›„ë³´:\n`;
            for (let i = 0; i < 5; i++) {
                const candidate = firstCandidates[i];
                const bar = 'â–ˆ'.repeat(Math.round(candidate.prob * 20));
                output.textContent += `${i + 1}. "${candidate.token}": ${(candidate.prob * 100).toFixed(1)}% ${bar}\n`;
            }
            
            output.textContent += `\nğŸ’­ ì˜ˆìƒ ë¬¸ì¥: "${seedText} ${topFirst.token}"\n\n`;
            output.textContent += `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n`;
            output.textContent += `ğŸ” ìƒì„¸í•œ ìƒì„± ê³¼ì • (${generateLength}ê°œ í† í°):\n\n`;
            
            // ìƒì„¸í•œ ìƒì„± ê³¼ì •
            for (let i = 0; i < generateLength; i++) {
                const logits = model.forward(currentSequence);
                
                const max = Math.max(...logits);
                const exps = logits.map(x => Math.exp(x - max));
                const sum = exps.reduce((a, b) => a + b, 0);
                const probs = exps.map(x => x / sum);
                
                const allCandidates = probs
                    .map((prob, idx) => ({prob, idx, token: reverseVocab.get(idx)}))
                    .sort((a, b) => b.prob - a.prob);
                
                output.textContent += `Step ${i + 1}: "${currentSequence.map(id => reverseVocab.get(id)).join(' ')}" â†’ ?\n`;
                
                // ìƒìœ„ 5ê°œë§Œ ë³´ì—¬ì£¼ê¸° (ë„ˆë¬´ ê¸¸ì–´ì§€ì§€ ì•Šê²Œ)
                for (let j = 0; j < Math.min(5, allCandidates.length); j++) {
                    const candidate = allCandidates[j];
                    const isSelected = j === 0;
                    const marker = isSelected ? 'ğŸ‘‰' : '  ';
                    const highlight = isSelected ? 'ã€ì„ íƒã€‘' : '';
                    
                    output.textContent += `${marker} "${candidate.token}": ${(candidate.prob * 100).toFixed(1)}% ${highlight}\n`;
                }
                
                const selectedCandidate = allCandidates[0];
                const nextTokenId = selectedCandidate.idx;
                const nextToken = selectedCandidate.token;
                
                generatedText += ' ' + nextToken;
                currentSequence.push(nextTokenId);
                
                if (currentSequence.length > 8) {
                    currentSequence = currentSequence.slice(-8);
                }
                
                output.textContent += `âœ… ê²°ê³¼: "${generatedText}"\n\n`;
                output.scrollTop = output.scrollHeight;
            }
            
            output.textContent += `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n`;
            output.textContent += `ğŸ‰ ìµœì¢… ì™„ì„±ëœ ë¬¸ì¥:\n"${generatedText}"\n\n`;
            
            // í›ˆë ¨ ë°ì´í„°ì™€ ë¹„êµ
            const originalText = document.getElementById('trainingData').value.toLowerCase();
            if (originalText.includes(seedText)) {
                const seedIndex = originalText.indexOf(seedText);
                const afterSeed = originalText.substring(seedIndex + seedText.length, seedIndex + seedText.length + 50);
                output.textContent += `ğŸ“š ì°¸ê³ : ì›ë³¸ ë°ì´í„°ì—ì„œ "${seedText}" ë‹¤ìŒ ë‚´ìš©:\n"${seedText}${afterSeed}..."\n\n`;
                
                if (afterSeed.trim().startsWith(topFirst.token)) {
                    output.textContent += `âœ… ì„±ê³µ! ëª¨ë¸ì´ ì˜¬ë°”ë¥¸ ë‹¤ìŒ ë‹¨ì–´ë¥¼ ì˜ˆì¸¡í–ˆìŠµë‹ˆë‹¤!`;
                } else {
                    output.textContent += `âŒ ì›ë³¸ê³¼ ë‹¤ë¥¸ ì˜ˆì¸¡ì´ì§€ë§Œ, ì´ê²ƒë„ ì°½ì˜ì ì¸ ê²°ê³¼ì…ë‹ˆë‹¤!`;
                }
            }
        }
        
        console.log('Simple LLM Demo ì¤€ë¹„ ì™„ë£Œ!');
    </script>
</body>
</html>
